/****************************************************************/
/* MOOSE - Multiphysics Object Oriented Simulation Environment  */
/*                                                              */
/*          All contents are licensed under LGPL V2.1           */
/*             See LICENSE for full restrictions                */
/****************************************************************/
#include "XFEMOutputs.h"
#include "FEProblem.h"
#include <iomanip>

template<>
InputParameters validParams<XFEMOutputs>()
{
  InputParameters params = validParams<ElementUserObject>();

  params.addRequiredCoupledVar("disp_x", "displacement in x direction");
  params.addCoupledVar("disp_y", "displacement in y direction");
  params.addCoupledVar("disp_z", "displacement in z direction");
  params.addParam<int>("direction", 3 ,"component");

  return params;
}

XFEMOutputs :: XFEMOutputs(const InputParameters & parameters) :
  ElementUserObject(parameters),
  _disp_x(&coupledNodalValue("disp_x", 0)),
  _disp_y(isCoupled("disp_y") ? &coupledNodalValue("disp_y", 0): NULL),
  _disp_z(isCoupled("disp_z") ? &coupledNodalValue("disp_z", 0): NULL),
  _num_nodes(_mesh.getMesh().n_nodes()),
  _mesh_dim(_mesh.getMesh().mesh_dimension()),
  _disp_dir(getParam<int>("direction")),
  _xfem(_fe_problem.get_xfem())
{
  _disp.push_back(_disp_x);
  if (_disp_y != NULL)
    _disp.push_back(_disp_y);
  if (_disp_z != NULL)
    _disp.push_back(_disp_z);
}

XFEMOutputs::~XFEMOutputs()
{
}


void
XFEMOutputs::initialize()
{
  if (_mesh_dim != 2)
    mooseError("XFEMOutputs only works for 2D mesh for now");
  _id_to_nodes.clear();
  _id_to_values.clear();
  _connectivity.clear();
  _num_emb_nodes = 0;
}

void
XFEMOutputs::execute()
{
  // get elem nodal values that are to be plotted
  std::vector<Real> elem_node_vals;
  for (unsigned int i = 0; i < _current_elem->n_nodes(); ++i)
  {
    Real node_val;
    Real disp_mag = 0.0;
    for (unsigned j = 0; j < _disp.size(); ++j)
      disp_mag += (*_disp[j])[i]*(*_disp[j])[i];
    disp_mag = std::sqrt(disp_mag);
    if (_disp_dir <= _disp.size()-1)
      node_val = (*_disp[_disp_dir])[i];
    else
      node_val = disp_mag;
    elem_node_vals.push_back(node_val);
  }

  // store element nodes, values and connectivity
  std::vector<unsigned int> elem_node_id;
  if (!_xfem->is_elem_cut(_current_elem))
  {
    for (unsigned int i = 0; i < _current_elem->n_nodes(); ++i)
    {
      Node* node = _current_elem->get_node(i);
      Point node_p(*node);
      for (unsigned int j = 0; j < _disp.size(); ++j) // loop over dims
        node_p(j) += (*_disp[j])[i];

      _id_to_nodes[node->id()] = node_p;
      _id_to_values[node->id()] = elem_node_vals[i];
      elem_node_id.push_back(node->id());
    } // i
  }
  else // this is a partial element
  {
    std::vector<std::vector<Point> > frag_edges;
    std::vector<int> frag_node_ids;
    std::vector<Real> frag_node_vals;
    _xfem->get_frag_faces(_current_elem, frag_edges, true);
    _xfem->get_frag_node_ids(_current_elem, frag_node_ids);
    _xfem->get_frag_values(_current_elem, elem_node_vals, frag_node_vals);
    for (unsigned int i = 0; i < frag_edges.size(); ++i)
    {
      int node_id = -1;
      if (frag_node_ids[i] >= 0)
        node_id = frag_node_ids[i];
      else // frag node is an embedded node
      {
        _num_emb_nodes += 1;
        node_id = _num_nodes + _num_emb_nodes - 1;
      }
      _id_to_nodes[node_id] = frag_edges[i][0];
      _id_to_values[node_id] = frag_node_vals[i];
      elem_node_id.push_back(node_id);
    } // i
  }
  _connectivity.push_back(elem_node_id);
}


void
XFEMOutputs::threadJoin(const UserObject & u )
{
}

void
XFEMOutputs::finalize()
{
  std::string file_id = numberToString(_t_step);
  std::string file_name = "disp_" + file_id + ".vtk";
  std::ofstream disp_file;
  disp_file.open(file_name.c_str());
  disp_file << "# vtk DataFile Version 2.0\n";
  disp_file << "Bulk mesh generated by UserObject XFEMOutputs\n";
  disp_file << "ASCII\nDATASET POLYDATA\n\n";

  // write points
  disp_file << "POINTS " << _id_to_nodes.size() << " DOUBLE\n";
  for (unsigned int i = 0; i < _id_to_nodes.size(); ++i)
  {
    Point node_p = _id_to_nodes[i];
    disp_file << std::setprecision(6) << std::scientific << node_p(0) << "  " << node_p(1) << "  " << node_p(2) << "\n";
  }

  // write connectivity
  unsigned int num_elems = _connectivity.size();
  unsigned int num_data = 0;
  for (unsigned int i = 0; i < _connectivity.size(); ++i)
    num_data += (_connectivity[i].size() + 1);
  disp_file << "\nPOLYGONS " << num_elems << " " << num_data << "\n";
  for (unsigned int i = 0; i < num_elems; ++i)
  {
    disp_file << _connectivity[i].size() << "  ";
    for (unsigned int j = 0; j < _connectivity[i].size(); ++j)
      disp_file << _connectivity[i][j] << "  ";
    disp_file << "\n";
  }

  // write values
  std::string var_name;
  if (_disp_dir == 0)
    var_name = "disp_x";
  if (_disp_dir == 1)
    var_name = "disp_y";
  if (_disp_dir == 2)
    var_name = "disp_z";
  else
    var_name = "disp_mag";

  disp_file << "\nPOINT_DATA  " << _id_to_values.size() << "\n" ;
  disp_file << "SCALARS " << var_name << " DOUBLE 1\n";
  disp_file << "LOOKUP_TABLE default\n";
  for (unsigned int i = 0; i < _id_to_values.size(); ++i)
    disp_file << std::setprecision(6) << std::scientific << _id_to_values[i] << "\n";

  disp_file.close();
}

template <typename T> std::string
XFEMOutputs::numberToString(T number)
{
  std::ostringstream ss;
  ss << std::setfill('0') << std::setw(4) << number;
  return ss.str();
}
